---
title: "[__cellcontacts__](https://github.com/juliaquach02/cellcontacts)"
output: md_document
author: "Julia Quach"
date: "2023-04-29"
bibliography: rmarkdown.bib
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

required <- c("celltrackR", "dplyr", "ggplot2", "RImageJROI", "spatstat", "sp", "sf","r2r","future", "RColorBrewer", "viridis", "tidyverse")
lapply( required, require, character.only = TRUE)

devtools::document()

```

--------------------------------------------------------------------------------

# __About__

--------------------------------------------------------------------------------

This R package was written to process imaging files acquired from live cell imaging of T cells and tumor cells. It requires the prior analysis of the live cell imaging films with a cell tracking tool, e.g., [TrackMate](https://imagej.net/plugins/trackmate/) or [Imaris](https://imaris.oxinst.com/products/imaris-for-tracking). It offers functions to compute cell-cell distances, cell-cell contacts, and characteristics of cell-cell interaction. Moreover, it allows to connect the results to immunological staining results.
 
--------------------------------------------------------------------------------

# __Goal of the project__

--------------------------------------------------------------------------------

The goal of this R package is to enable the quantitative analysis of T cell-tumor cell interaction in live cell imaging films.

--------------------------------------------------------------------------------

# __Installation__ 

--------------------------------------------------------------------------------

The latest development version of cellcontacts can be installed from GitHub:

```{r, eval = FALSE}
devtools::install_github( "juliaquach02/cellcontacts" )
```
The package can be loaded via:

```{r cellcontacts}
library( cellcontacts )
```

--------------------------------------------------------------------------------

# __Work flow__

--------------------------------------------------------------------------------

The package was built to analyze 2D live-cell imaging movies. Before using the package,
the cells need to segmented and tracked, for example using the Fiji plugin 
[TrackMate](https://imagej.net/plugins/trackmate/) by Tinevez at al [@RN293]. 

The cellcontacts package processes 

* ROIs representing segmented cells, which are saved as .roi-files in a zipped folder, and 
* cell tracks, which are saved as .csv file with the columns "Label", "X", "Y", "Frame".


### __Preprocessing__

For the segmentation and tracking of the cells in the live-cell imaging film, TrackMate proves to be a useful tool. It is a modular tool that enables the segmentation and tracking of cells via common segmentation tools, e.g. [StarDist](https://imagej.net/plugins/stardist), 
and tracking tools, e.g. the [LAP tracker](https://www.nature.com/articles/nmeth.1237). 

The cellcontacts package requires the segmentation and tracking of tumor and T cells as two separate cell populations. Cell areas, called cell ROIs (region of interest), should be named by their track name with incremented index in the format *Track_[id]_[index]* and saved as .roi-files in a zipped folder. Please be aware that RStudio cannot load files with a "\." in their file name. Furthermore, cell tracks should be saved from the TrackMate GUI as .csv file and only the first line of the .csv file should contain the column headers.

### __Setting directories and loading the data__

Firstly, source and destination directories need to be set. To import the cell tracks, we simply use the `read.table()` function. To import the cell ROIs, we use the `read.ijzip()` function from the [RImageJROI](https://cran.r-project.org/web/packages/RImageJROI/index.html) package. 
As the number of ROIs can be very large, we might need to split the zipped ROIs into multiple zipped subfolders and load the folders in parallel using the [future](https://cran.r-project.org/web/packages/future/index.html) package. To save the ROIs into separate subfolders, an ImageJ macro is provided [here](ImageJ_Macros/Macro_Rename_and_Save_ROIs_in_Subfolders.ijm).

```{r directories and import, include=FALSE}

# Setting directories ----------------------------------------------------------

# Source directory to ROIs 
tumorROIsPath <- paste0(getwd(), "/Example/Tumour_Cells/RoiSet_Tumour_Cells/")
tcellROIsPath <- paste0(getwd(), "/Example/T_Cells/RoiSet_T_Cells/")
endPointROIPath <- paste0(getwd(),"/Example/Endpoint_Measurement/RoiSet_Endpoint_DAPI.zip")

# Source directory to tracks and track information
tumorTracksPath <-  paste0(getwd(),"/Example/Tumour_Cells/Tracks_Tumour_Cells.csv")
tcellTracksPath <-  paste0(getwd(), "/Example/T_Cells/Tracks_T_Cells.csv")

# Source directory to endpoint measurement of signal intensity
endPointMeasPath <- paste0(getwd(), "/Example/Endpoint_Measurement/Results_Endpoint_Intensity_p21.csv")

# Destination directory for plots and exported data frames
resultsPath <- paste0(getwd(), "/Example/Results/")

# Importing tracks ----------------------------------------------------

# Load track information as txt

tumorTracksTxt <- read.table( tumorTracksPath, header = TRUE, sep = ",", )
tcellTracksTxt <- read.table( tcellTracksPath, header = TRUE, sep = ",",)

# Load endpoint data ----------------------------------------------------

endPointROIs <- read.ijzip( endPointROIPath )
endPointMeasTxt <- read.table( endPointMeasPath, header = TRUE, sep = ",", )

# Load tumour ROIs of movie -----------------------------------------------------------

# Create list of zipped ROI folders
numSubfolders <- 14 # Adjust numSubfolders for each data set
pathROIs <- list()

for( i in 1:numSubfolders){
  pathROIs[[i]] <- paste0(tumorROIsPath, as.character(i-1), ".zip")
}

# Subdivide list into two lists to create two jobs
pathROIsPt1 <- pathROIs[ 1:floor(numSubfolders/2) ]
pathROIsPt2 <- pathROIs[ (floor(numSubfolders/2) + 1):numSubfolders ]

# Load ROIs in parallel
plan(multisession)

# job 1
ROIsPt1 %<-% {
  ROIsPt1 <- lapply( pathROIsPt1, read.ijzip)
}

# job 2
ROIsPt2 %<-%{
  ROIsPt2 <- lapply( pathROIsPt2, read.ijzip)
}

tumorROIs <- append( ROIsPt1, ROIsPt2)

rm(ROIsPt1, ROIsPt2) # Clear memory

# Load T cell ROIs of movie -----------------------------------------------------------

# Create list of zipped ROI folders
numSubfolders <- 2 #### Set numSubfolders for each data set
pathROIs <- list()

for( i in 1:numSubfolders){
  pathROIs[[i]] <- paste0(tcellROIsPath, as.character(i-1), ".zip")
}

# Subdivide list into two lists to create two jobs
pathROIsPt1 <- pathROIs[ 1:floor(numSubfolders/2) ]
pathROIsPt2 <- pathROIs[ (floor(numSubfolders/2) + 1):numSubfolders ]


# Load ROIs in parallel

plan(multisession)

# job 1
ROIsPt1 %<-% {
  ROIsPt1 <- lapply( pathROIsPt1, read.ijzip)
}

# job 2
ROIsPt2  %<-% {
  ROIsPt2 <- lapply( pathROIsPt2, read.ijzip)
}

tcellROIs <- append(ROIsPt1, ROIsPt2)


rm(ROIsPt1, ROIsPt2) # Clear memory

```

### __Analysis__

To compute cell-cell contacts for a large set of segmented cells, we need to put the data into a suitable data structure to allow easy and efficient computation and access.


### 1. Matching track names to their frame number

Using the function `matchTrackNamesWithFrameNum()`, we assign the cell ROIs to their corresponding frame number.

```{r matching track names to frame number}

tumor_trackName_frameNum <- matchTrackNamesWithFrameNum( tumorTracksTxt )
tcell_trackName_frameNum <- matchTrackNamesWithFrameNum( tcellTracksTxt )

print( head( tumor_trackName_frameNum ))
print( head( tcell_trackName_frameNum ))

```


### 2. Putting data into hash maps

For an efficient retrieval of our data during computation, we put our data set into hash maps. We sort the cell ROIs into a 2D grid with a column and row width of 100 &micro;m to get rough estimates of their position. With those hash maps, we can access:

* For a specific frame number, the track names of all cells in that time point.
* The a specific cell ROI name, the center point of that cell at that time point.
* For a specific cell ROI name, the rough position in the frame if we put a 2D grid over that frame.

```{r hash maps}

# Hash map names to coordinates
tumorROImap <- hashmap( default = "No value for this key")
invisible( lapply( tumorROIs, insert_Hashmap_NamesToCoords, ROImap = tumorROImap) )

tcellROImap <- hashmap( default = "No value for this key")
invisible(  lapply( tcellROIs, insert_Hashmap_NamesToCoords, ROImap = tcellROImap)  )

# Hash map time points to names
insert_Hashmap_FrameNumToNames( tumor_trackName_frameNum, ROImap = tumorROImap )
insert_Hashmap_FrameNumToNames( tcell_trackName_frameNum, ROImap = tcellROImap )

# Hash map names to center points
tumorROImap_center <- hashmap( default = "No value for this key")
tcellROImap_center <- hashmap( default = "No value for this key")

invisible( lapply( tumorROIs, insert_Hashmap_NamesToCenter, ROImap = tumorROImap_center ) )
invisible( lapply( tcellROIs, insert_Hashmap_NamesToCenter, ROImap = tcellROImap_center ) )

# Hash map names to field in grid of respective ROI center point
grid <- create_grid( c(0,600), c(0,600), dim = 6) ### Frame dimensions should be checked for each data set

tumorROImap_NamesToGrid <- hashmap( default = "No value for this key")
tcellROImap_NamesToGrid <- hashmap( default = "No value for this key")

invisible( lapply( tumorROIs, insert_Hashmap_NamesToGrid, ROImap = tumorROImap_NamesToGrid, grid = grid ) )
invisible( lapply( tcellROIs, insert_Hashmap_NamesToGrid, ROImap = tcellROImap_NamesToGrid, grid = grid ) )

# Put endPointROIs into field and hashmap
endpointROImap <- hashmap( default = "No value for this key")
insert_Hashmap_NamesToCoords( endPointROIs, endpointROImap)
insert_Hashmap_NamesToGrid( endPointROIs, ROImap = tumorROImap_NamesToGrid, grid = grid  )

```

```{r hashmap additional code, include = FALSE}
# Add last time point to both hash maps
lastTimepoint <- max( as.integer( tumor_trackName_frameNum$Frame ), as.integer( tcell_trackName_frameNum$Frame ) )

tumorROImap[["lastTimepoint"]] <- lastTimepoint
tcellROImap[["lastTimepoint"]] <- lastTimepoint

# Delete loaded zip folders to clear memory -------------------------------
rm( tumorROIs )
rm( tcellROIs )
gc()

```


### 3. Mapping tracks to endpoint staining

We often want to connect the dynamic information of the cell tracks to the static information of the same cells from immunological staining.
For this, we provide the function `match_to_endpoint_ROIs()` to match the cell tracks to the corresponding cell ROIs at the end point. The function `add_meas_to_matches()` can add the measurements of the signal intensity to the mapping of cell tracks to endpoint ROIs.

```{r mapping to endpoint}

# Map tumor tracks from movie to endpoint staining ----------------------------
matches <- match_to_endpoint_ROIs(  endPointROIs, endpointROImap, tumorROImap, tumorROImap_center, tumorROImap_NamesToGrid )

# Add measurement results to matches
result <- add_meas_to_matches( matches, endPointMeasTxt )
print( head( result ) )

```

To check the mapping, we can plot the matched endpoint ROIs and cell tracks by their color in one plot:

<center>
![Matched_ROIs](Plot_Matched_ROIs.jpg){#id .class width=56% height=51.2%}     
*Cell areas at least time point are mapped to the cell areas from the immunological staining at the endpoint. Matched cells are plotted in the same colour.*
</center>


### 4. Computing cell-cell distances

Cell-cell distances need to be computed to filter for cell-cell contacts. For this, we provide the function `compute_distTimepoint_wGrid()`. 

This function computes for a given time point all possible tumour cell/T cell pairs. For each pair, the function firstly checks the rough position of both cells using their position in the 2D grid. If the distance of the pair is below 200 &micro;m, the euclidean distance between the cell ROI is computed. 

The output of the function is a data frame which lists all possible cell pairs and either the distance of the pair or a remark that the distance is substantially larger than the distance threshold for a cell-cell contact.

```{r cell-cell distances}
cellDist <- lapply( 0: tumorROImap[["lastTimepoint"]], compute_distTimepoint_wGrid,
                              gridWidth = 100,
                              ROImap1 = tumorROImap,
                              ROImap2 = tcellROImap,
                              ROImapField1 = tumorROImap_NamesToGrid,
                              ROImapField2 = tcellROImap_NamesToGrid )

print( head(cellDist[[1]]) )

```


### 5. Filtering for cell-cell contacts

To filter the cell pairs for cell-cell contacts, we only keep cell pairs that maintain a distance below a distance threshold for a minimum duration of frames. The distance and duration thresholds can be set manually. 

As result, we obtain a list of tumour cell/T cell pairs and each list entry represents one pair and contains the columns "time point" and "distances".

```{r cell-cell contacts}

# Set a threshold for the minimum duration of a contact
minDuration <- 4

# To filter for cell-cell contacts, we use pipes from the tidyverse package.
pairs <- cellDist %>% 
    add_columnPair() %>% # Add column pair
    lapply( add_columnTimepoint, tumor_trackName_frameNum = tumor_trackName_frameNum) %>% # Add column time point
    lapply( check_contacts, distThresh = 7) %>% # Evaluate whether the distance is below threshold
    lapply( keep_contactTrue)  %>% # Keep only pairs with distance below threshold
    Filter(Negate(is.null), .) %>% # Discard empty list entries
    .[lapply( ., nrow) > 0]  %>% 
    lapply( as.data.frame ) %>%  
    bind_rows() %>%  
    split( ., .$pair) %>%  # Split by pair
    .[ lapply( ., nrow) > minDuration] # Get all pairs above minimum duration

print(head(pairs[[1]]))

```


### 6. Validation and export of results

For a visual validation of the computed cell-cell contacts, we export the track information of the T cells that were in contact as .csv-file via the function `prepareExportContacts()` and `write.csv()`. 

```{r export}
# Export computed contacts as .csv ----------------------------------------

tumorTracksTxt_inContact <- prepareExportContacts( pairs, tumorTracksTxt, cellType = "tumorCell")
tcellTracksTxt_contact <- prepareExportContacts( pairs, tcellTracksTxt, cellType = "TCell")

# Export as .csv
write.csv( tumorTracksTxt_inContact, paste0(resultsPath, "Tracks_Tumour_Cells_in_contatact.csv"), row.names=FALSE)
write.csv( tcellTracksTxt_contact, paste0(resultsPath, "Tracks_T_Cells_in_contact.csv"), row.names=FALSE)
```

The exported files are loaded into TrackMate via ImageJ > Plugins > Tracking > TrackMate CSV Importer. Using the .csv file, TrackMate labels the T cells in the film only *during* a contact. 

This allows us to revisit the live-cell imaging film and to check whether cell-cell contacts are correctly computed. 

<center>
![TrackMate_CSV_Importer](Screenshot_TrackMate_CSV_Importer.JPG){#id .class width=80% height=80%}     
*Via the TrackMate CSV Importer GUI, we can load our results back into a TrackMate session. For this, we choose the image and the .csv file. For the .csv file, we add information on the content of its columns.*
</center>

--------------------------------------------------------------------------------

# __Data__

--------------------------------------------------------------------------------

The example folder contains the following files:

* Segmented cell ROIs for tumor and T cells as .roi files in multiple zipped folders
* Cell tracks for tumor and T cells as .csv files
* The TrackMate sessions for the analysis of tumor cells and T cells saved as .xml files
* An immunological staining image of the tumor cells and T cells at the endpoint of the live-cell imaging film with a DAPI, phalloidin and p21 channel.
* The results regarding cell-cell distances and cell-cell contacts achieved with the cellcontacts package.
* The R script to run the above mentioned analyses.

For more questions and remarks, feel free to open an issue on GitHub.

--------------------------------------------------------------------------------

# __References__

--------------------------------------------------------------------------------

